%!TEX root = ../documentation.tex

\chapter{Implementierung}

Viele implementieren Features beinhalten nur das einfache darstellen von Dialogen oder das Starten von Intents. Daher wird in diesem Abschnitt nur auf dem RecyclerView und dessen Verwendung eingegangen, da dieser eine tiefgründigere Dokumentation erfordert. 

Allgemein ist der RecyclerView eine Verbesserung des ListView's und dient der Darstellung von Informationen. Weiterhin bietet der RecyclerView eine bessere Performance gegenüber dem älteren ListView und ist freier gestaltbar. Zudem können einzelne Inhalte des RecyclerView's dynamisch ausgetauscht werden, ohne die komplette Ansicht neu zu laden. Um Inhalt darzustellen benötigt der RecyclerView  einen LayoutManager der den Inhalt verwaltet, einen RecyclerViewAdapter, indem der darzustellende Inhalt gespeichert wird und eine Activity / ein Fragment indem der Inhalt angezeigt wird. In diesem Projekt wurde als LayoutManager der Standardlayoutmanager \enquote{LinearLayoutManager} verwendet. Der RecyclerViewAdapter wurde selbst implementiert, um diesem auf die gegebenen Daten anzupassen. Der RecyclerViewAdapter beinhaltet die Klasse ViewHolder, von der für jedes angezeigte Objekt eine Instanz erzeugt wird. Im ViewHolder werden zum einem Referenzen auf das Layout des anzuzeigenden Inhalts gespeichert und zum anderen auf dem gespeicherten Layout, Listener für Klick-Events definiert. In der Methode \enquote{onCreateViewHolder()} wird im RecyclerViewAdapter ein neuer ViewHolder angelegt und diesem das definierte CardLayout zugewiesen. Wenn das entsprechende Objekt auf dem Bildschirm des Nutzers aktiv ist (sprich angezeigt wird), ruft der LayoutManager die Methode \enquote{onBindViewHolder()} auf. In dieser Methode werden die anzuzeigenden Daten der Card geladen und beispielsweise auch das Vorschaubild durch einen \enquote{AsnycTask} erzeugt. Wird eine Card inaktiv (sprich wird nicht mehr angezeigt) wird das ViewHolder Objekt auf einen Stack gelegt. Sollte dieses Objekt wieder in den sichtbaren Bereich des Bildschirm kommen, versucht der RecyclerView, das alte Objekt wieder zu verwenden (zu recyclen). Dadurch steigt die Performance der App. 

Um dynamisch den Inhalt des RecylcerView austauschen bietet dieser verschiedene Methoden. Die einfachste Methode um den Inhalt zu tauschen, wenn man nicht weiß welche Inhalte geändert wurden, ist die Methode \enquote{mRecyclerView.swapAdapter(mAdapter, false)} mit einem neuen RecyclerViewAdapter aufzurufen. Dabei tauscht der RecyclerView nur neue / geänderte Elemente aus.

Um alle Benutzer Events auf dem RecyclerView Inhalt (den Cards) kümmert sich der der ViewHolder. Einfache Intent-Starts sind damit zu realisieren. Komplexer wird dies, wenn die App wissen muss welche Card angetippt wurde, oder beispielsweise \enquote{long taps} registriert werden müssen, da der ViewHolder nicht von \enquote{View} erbt, sondern von \enquote{RecyclerView.ViewHolder}. Dieser stellt keine Implementierungen der Methoden \enquote{onCreateContextMenu} und \enquote{onContextItemSelected} bereit und zudem existiert zu den einzelnen Cards keine Code-Behind-Klasse. Daher wurde ein eigener RecyclerView implementiert, der den Standard RecyclerView um einen ContextMenuHolder erweitert und Informationen über das angeklickte Objekt speichert und somit eine Implementierung eines Kontextmenüs ermöglicht.